var documenterSearchIndex = {"docs":
[{"location":"#BinaryBuilderBase.jl-Documentation","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.jl Documentation","text":"","category":"section"},{"location":"","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.jl Documentation","text":"This is the reference documentation of BinaryBuilderBase.jl.","category":"page"},{"location":"#Index","page":"BinaryBuilderBase.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.jl Documentation","text":"","category":"page"},{"location":"#Types","page":"BinaryBuilderBase.jl Documentation","title":"Types","text":"","category":"section"},{"location":"#BinaryBuilderBase.AbstractDependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.AbstractDependency","text":"An AbstractDependency is a binary dependency of the JLL package.  Dependencies are installed to ${prefix} in the build environment.\n\nConcrete subtypes of AbstractDependency are\n\nDependency: a JLL package that is necessary for to build the package and to load the generated JLL package.\nRuntimeDependency: a JLL package that is necessary only at runtime.  Its artifact will not be installed in the prefix during the build.\nBuildDependency: a JLL package that is necessary only to build the package.  This will not be a dependency of the generated JLL package.\nHostBuildDependency: similar to BuildDependency, but it will install the artifact for the host platform, instead of that for the target platform.\n\nSubtypes of AbstractDependency should define the following traits:\n\nis_host_dependency\nis_target_dependency\nis_build_dependency\nis_runtime_dependency\n[is_top_level_dependency][@ref]\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.AbstractSource","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.AbstractSource","text":"An AbstractSource is something used as source to build the package.  Sources are installed to ${WORKSPACE}/srcdir in the build environment.\n\nConcrete subtypes of AbstractSource are:\n\nArchiveSource: a remote archive to download from the Internet;\nFileSource: a remote file to download from the Internet;\nGitSource: a remote Git repository to clone;\nDirectorySource: a local directory to mount.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.AnyPlatform","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.AnyPlatform","text":"AnyPlatform()\n\nA special platform to be used to build platform-independent tarballs, like those containing only header files.  FileProduct is the only product type allowed with this platform.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.ArchiveSource","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.ArchiveSource","text":"ArchiveSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote archive in one of the supported archive formats (e.g., TAR or ZIP balls) to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the archive will be automatically unpacked to ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.BuildDependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.BuildDependency","text":"BuildDependency(dep::Union{PackageSpec,String}; platforms)\n\nDefine a binary dependency that is necessary only to build the package.  The dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.Dependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.Dependency","text":"Dependency(dep::Union{PackageSpec,String}, build_version::VersionNumber;\n           compat::String, platforms::Vector{<:AbstractPlatform})\n\nDefine a binary dependency that is necessary to build the package and load the generated JLL package.  The argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional positional argument build_version can be used to specify the version of the dependency to be installed when building it.  If not specified, the latest version of the package compatible with the environment will be automatically chosen by the package resolver, unless compat is specified, see below.\n\nThe optional keyword argument compat can be used to specify a string for use in the Project.toml of the generated Julia package.  If compat is non-empty and build_version is not passed, the latter defaults to the minimum version compatible with the compat specifier.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\nThe optional keyword argument top_level denotates that this dependency is platform independent. It implies that the platforms keyword argument is set to [AnyPlatform()]. The primary use-case is for packages that hold information about the platform selection using Preferences. Platform selection is cached and in the case that no platform is available we need to be able to invalidate said cache. Invalidation occurs through the package that owns the Preferences data.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.DirectorySource","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.DirectorySource","text":"DirectorySource(path::String; target::String = basename(path), follow_symlinks=false)\n\nSpecify a local directory to mount from path.\n\nThe content of the directory will be mounted in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword target, if provided. Symbolic links are replaced by a copy of the target when follow_symlinks is true.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.DockerRunner","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.DockerRunner","text":"DockerRunner\n\nUse docker as an execution engine; a reasonable backup for platforms that do not have user namespaces (e.g. MacOS, Windows).\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.ExecutableProduct","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.ExecutableProduct","text":"An ExecutableProduct is a Product that represents an executable file.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\nExecutableProduct(binname, varname::Symbol, dir_path=\"bin\")\n\nDeclares an ExecutableProduct that points to an executable located within the prefix.  binname specifies the basename of the executable, varname is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the bindir, but you can specify a different directory within the prefix with the dir_path argument.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.FileProduct","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.FileProduct","text":"FileProduct(path, varname::Symbol, dir_path = nothing)\n\nDeclares a FileProduct that points to a file located relative to the root of a Prefix, must simply exist to be satisfied. The first argument path is either a single AbstractString  or a Vector{String} to allow several paths to be checked.   \n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.FileSource","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.FileSource","text":"FileSource(url::String, hash::String; filename::String = basename(url))\n\nSpecify a remote file to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the file will be saved under ${WORKSPACE}/srcdir with the same name as the basename of the originating URL, unless the the keyword argument filename is specified.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.FrameworkProduct","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.FrameworkProduct","text":"A FrameworkProduct is a  Product that encapsulates a macOS Framework. It behaves mostly as a LibraryProduct for now, but is a distinct type. This implies that for cross-platform builds where a library is provided as a Framework on macOS and as a normal library on other platforms, two calls to BinaryBuilder's build_tarballs are needed: one with the LibraryProduct and all non-macOS platforms, and one with the FrameworkProduct and the MacOS platforms.\n\n\n\nFrameworkProduct(fwnames, varname::Symbol)\n\nDeclares a macOS FrameworkProduct that points to a framework located within the prefix, with a name containing fwname appended with .framework.  As an example, given that fwname is equal to QtCore, this would be satisfied by the following path:\n\nlib/QtCore.framework\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.GitSource","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.GitSource","text":"GitSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote Git repository to clone form url.  hash is the 40-character SHA1 revision to checkout after cloning.\n\nThe repository will be cloned in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.HostBuildDependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.HostBuildDependency","text":"HostBuildDependency(dep::Union{PackageSpec,String}; platforms)\n\nDefine a binary dependency that is necessary only to build the package. Different from the BuildDependency, the artifact for the host platform will be installed, instead of that for the target platform.\n\nThe dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.LibraryProduct","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.LibraryProduct","text":"A LibraryProduct is a special kind of Product that not only needs to exist, but needs to be dlopen()'able.  You must know which directory the library will be installed to, and its name, e.g. to build a LibraryProduct that refers to \"/lib/libnettle.so\", the \"directory\" would be \"/lib\", and the \"libname\" would be \"libnettle\".  Note that a LibraryProduct can support multiple libnames, as some software projects change the libname based on the build configuration.\n\n\n\nLibraryProduct(libname, varname::Symbol, dir_paths=String[];\n               dont_dlopen=false, dlopen_flags=Symbol[])\n\nDeclares a LibraryProduct that points to a library located within the prefix. libname specifies the basename of the library, varname is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the libdir, but you can add other directories within the prefix to the dir_paths argument.  You can specify the flags to pass to dlopen as a vector of Symbols with the dlopen_flags keyword argument.  If the library should not be dlopen'ed automatically by the JLL package, set dont_dlopen=true.\n\nFor example, if the libname is libnettle, this would be satisfied by the following paths:\n\nlib/libnettle.so or lib/libnettle.so.6 on Linux and FreeBSD;\nlib/libnettle.6.dylib on macOS;\nlib/libnettle-6.dll on Windows.\n\nLibraries matching the search pattern are rejected if they are not dlopen()'able.\n\nIf you are unsure what value to use for libname, you can use Base.BinaryPlatforms.parse_dl_name_version:\n\njulia> using Base.BinaryPlatforms\n\njulia> parse_dl_name_version(\"sfml-audio-2.dll\", \"windows\")[1]\n\"sfml-audio\"\n\nIf the library would have different basenames on different operating systems (e.g., libz.so on Linux and FreeBSD, libz.dylib on macOS, and zlib.dll on Windows), libname can be also a vector of Strings with the different alternatives:\n\nLibraryProduct([\"libz\", \"zlib\"], :libz)\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.Product","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.Product","text":"A Product is an expected result after building or installation of a package.\n\nExamples of Products include LibraryProduct, FrameworkProduct, ExecutableProduct and FileProduct. All Product types must define the following minimum set of functionality:\n\nlocate(::Product): given a Product, locate it within the wrapped Prefix returning its location as a string\nsatisfied(::Product): given a Product, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)\nvariable_name(::Product): return the variable name assigned to a Product\nrepr(::Product): Return a representation of this Product, useful for auto-generating source code that constructs Products, if that's your thing.\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.RuntimeDependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.RuntimeDependency","text":"RuntimeDependency(dep::Union{PackageSpec,String}; compat::String, platforms::Vector{<:AbstractPlatform}, top_level::Bool=false)\n\nDefine a binary dependency that is only listed as dependency of the generated JLL package, but its artifact is not installed in the prefix during the build.  The dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument compat can be used to specify a string for use in the Project.toml of the generated Julia package.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\nThe optional keyword argument top_level specifies whether the dependency should be use only at the top-level of the generated JLL package, instead of inside each platform-specific wrapper.  Using top_level=true is useful for packages needed for platform augmentation (e.g. MPIPreferences.jl).\n\n\n\n\n\n","category":"type"},{"location":"#BinaryBuilderBase.UserNSRunner","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.UserNSRunner","text":"UserNSRunner\n\nA UserNSRunner represents an \"execution context\", an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use run() to actually run commands within the UserNSRunner, and runshell() as a quick way to get an interactive shell within the crossbuild environment.\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"BinaryBuilderBase.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"#BinaryBuilderBase.abi_agnostic-Tuple{Platform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.abi_agnostic","text":"abi_agnostic(p::AbstractPlatform)\n\nStrip out any tags that are not the basic annotations like libc and call_abi.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.accept_apple_sdk","text":"accept_apple_sdk(ins::IO, outs::IO) -> Bool\n\nAsk the user whether they accept the terms of the macOS SDK, and return a boolean with their choice.  Write messages to outs, read input from ins.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.artifact_name","text":"artifact_name(cs::CompilerShard)\n\nReturn the bound artifact name for a particular shard.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.bindir-Tuple{Prefix}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.bindir","text":"bindir(prefix::Prefix)\n\nReturns the binary directory for the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.choose_shards-Tuple{Base.BinaryPlatforms.AbstractPlatform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.choose_shards","text":"choose_shards(p::AbstractPlatform; rootfs_build, ps_build, GCC_builds,\n                           LLVM_builds, archive_type)\n\nThis method chooses, given a Platform, which shards to download, extract and mount, returning a list of CompilerShard objects.  At the moment, this always consists of four shards, but that may not always be the case.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.chown_cleanup","text":"chown_cleanup(dr::DockerRunner)\n\nOn Linux, the user id inside of the docker container doesn't correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to chown -R $(id -u):$(id -g) $prefix, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.collect_jll_uuids-Tuple{Pkg.Types.Manifest, Set{Base.UUID}}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.collect_jll_uuids","text":"collect_jll_uuids(manifest::Pkg.Types.Manifest, dependencies::Set{Base.UUID})\n\nReturn a Set of all JLL packages in the manifest with dependencies being the list of direct dependencies of the environment.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.compress_dir-Tuple{AbstractString}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.compress_dir","text":"compress_dir(dir::AbstractString;\n             compressor_stream = GzipCompressorStream,\n             level::Int = 9,\n             extension::AbstractString = \".gz\",\n             verbose::Bool = false)\n\nCompress all files in dir using the specified compressor_stream with compression level equal to level, appending extension to the filenames. Remove the original uncompressed files at the end.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.download_all_artifacts-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.download_all_artifacts","text":"download_all_artifacts(; verbose::Bool=false)\n\nHelper function to download all shards/helper binaries so that no matter what happens, you don't need an internet connection to build your precious, precious binaries.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.download_source","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.download_source","text":"download_source(source::AbstractSource; verbose::Bool = false)\n\nDownload the given source.  All downloads are cached within the BinaryBuilder downloads storage directory.\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.enable_apple_file-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.enable_apple_file","text":"enable_apple_file()\n\nReturn the path to file that, if exists, indicates that the user accepts to download macOS SDK.  The file is automatically created when the package is loaded if the environment variable BINARYBUILDER_AUTOMATIC_APPLE is set to \"true\".\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.expand_cxxstring_abis-Tuple{Base.BinaryPlatforms.AbstractPlatform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.expand_cxxstring_abis","text":"expand_cxxstring_abis(p::AbstractPlatform; skip=Sys.isbsd)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the cxxstring_abi tag within the Platform object.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.\n\nIf the given Platform already specifies a cxxstring_abi (as opposed to nothing) only that Platform is returned.  If skip is a function for which skip(platform) evaluates to true, the given platform is not expanded.  By default FreeBSD and macOS platforms are skipped, due to their lack of a dependence on libstdc++ and not needing this compatibility shim.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.expand_gfortran_versions-Tuple{Base.BinaryPlatforms.AbstractPlatform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.expand_gfortran_versions","text":"expand_gfortran_versions(p::AbstractPlatform)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the libgfortran_version tag within the Platform.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given Platform already specifies a libgfortran_version (as opposed to nothing) only that Platform is returned.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.expand_microarchitectures","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.expand_microarchitectures","text":"expand_microarchitectures(p::AbstractPlatform, [microarchitectures::Vector{String}])\n\nGiven a Platform, returns a vector of Platforms with differing march attributes as specified by the ARCHITECTURE_FLAGS mapping.  If the given Platform alread has a march tag specified, only that platform is returned.  If the microarchitectures argument is given, limit the expansion to the given microarchitectures.\n\njulia> using BinaryBuilderBase\n\njulia> expand_microarchitectures(Platform(\"x86_64\", \"freebsd\"))\n4-element Vector{Platform}:\n FreeBSD x86_64 {march=x86_64}\n FreeBSD x86_64 {march=avx}\n FreeBSD x86_64 {march=avx2}\n FreeBSD x86_64 {march=avx512}\n\njulia> expand_microarchitectures(Platform(\"armv7l\", \"linux\"))\n2-element Vector{Platform}:\n Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}\n\njulia> expand_microarchitectures(Platform(\"aarch64\", \"linux\"), [\"armv8_0\", \"a64fx\"])\n2-element Vector{Platform}:\n Linux aarch64 {libc=glibc, march=armv8_0}\n Linux aarch64 {libc=glibc, march=a64fx}\n\njulia> expand_microarchitectures(Platform(\"i686\", \"windows\"))\n2-element Vector{Platform}:\n Windows i686 {march=pentium4}\n Windows i686 {march=prescott}\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.expand_microarchitectures-2","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.expand_microarchitectures","text":"expand_microarchitectures(ps::Vector{<:Platform}, [microarchitectures::Vector{String}];\n                          filter=Returns(true))\n\nExpand all platforms in the vector ps with the supported microarchitectures.\n\nIf the microarchitectures argument is given, limit the expansion to the given platforms.  This is useful if you do not want to expand to all available microarchitectures.\n\nThe expansion is applied only to the platforms matching the filter predicate, by default all platforms.  This is useful if you want to limit the expansion to some platforms, without having to explicitly list its microarchitectures in the second argument.\n\njulia> using BinaryBuilderBase\n\njulia> expand_microarchitectures(filter!(p -> Sys.islinux(p) && libc(p) == \"glibc\", supported_platforms()))\n15-element Vector{Platform}:\n Linux i686 {libc=glibc, march=pentium4}\n Linux i686 {libc=glibc, march=prescott}\n Linux x86_64 {libc=glibc, march=x86_64}\n Linux x86_64 {libc=glibc, march=avx}\n Linux x86_64 {libc=glibc, march=avx2}\n Linux x86_64 {libc=glibc, march=avx512}\n Linux aarch64 {libc=glibc, march=armv8_0}\n Linux aarch64 {libc=glibc, march=armv8_1}\n Linux aarch64 {libc=glibc, march=armv8_2_crypto}\n Linux aarch64 {libc=glibc, march=a64fx}\n Linux armv6l {call_abi=eabihf, libc=glibc, march=arm1176jzfs}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}\n Linux powerpc64le {libc=glibc, march=power8}\n Linux riscv64 {libc=glibc, march=riscv64}\n\njulia> expand_microarchitectures(filter!(p -> Sys.islinux(p) && libc(p) == \"glibc\", supported_platforms()), [\"x86_64\", \"avx2\"])\n8-element Vector{Platform}:\n Linux i686 {libc=glibc}\n Linux x86_64 {libc=glibc, march=x86_64}\n Linux x86_64 {libc=glibc, march=avx2}\n Linux aarch64 {libc=glibc}\n Linux armv6l {call_abi=eabihf, libc=glibc}\n Linux armv7l {call_abi=eabihf, libc=glibc}\n Linux powerpc64le {libc=glibc}\n Linux riscv64 {libc=glibc}\n\njulia> expand_microarchitectures(filter!(p -> Sys.islinux(p) && libc(p) == \"glibc\", supported_platforms()); filter=p->arch(p)==\"x86_64\")\n10-element Vector{Platform}:\n Linux i686 {libc=glibc}\n Linux x86_64 {libc=glibc, march=x86_64}\n Linux x86_64 {libc=glibc, march=avx}\n Linux x86_64 {libc=glibc, march=avx2}\n Linux x86_64 {libc=glibc, march=avx512}\n Linux aarch64 {libc=glibc}\n Linux armv6l {call_abi=eabihf, libc=glibc}\n Linux armv7l {call_abi=eabihf, libc=glibc}\n Linux powerpc64le {libc=glibc}\n Linux riscv64 {libc=glibc}\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.filter_platforms-Tuple{AbstractVector{<:AbstractDependency}, Base.BinaryPlatforms.AbstractPlatform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.filter_platforms","text":"filter_platforms(deps::AbstractVector{<:AbstractDependency}, p::AbstractPlatform)\n\nFilter the dependencies deps which are compatible with platform p.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.gcc_version","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.gcc_version","text":"gcc_version(p::AbstractPlatform, GCC_builds::Vector{GCCBuild},\n            compilers::Vector{Symbol}=[:c];\n            llvm_version::Union{Nothing,VersionNumber}=nothing)\n\nReturns the closest matching GCC version number for the given particular platform, from the given set of options.  The compiler ABI and the microarchitecture of the platform will be taken into account.  If no match is found, returns an empty list.  compilers is the list of compilers used in the build, to choose the right version of GCC to couple with them if necessary.  If the keyword argument llvm_version is passed, it is used to filter the version of GCC for FreeBSD platforms.\n\nThis method assumes that the compiler ABI of the platform represents a platform that binaries will be run on, and thus versions are always rounded down; e.g. if the platform supports a libstdc++ version that corresponds to GCC 5.1.0, but the only GCC versions available to be picked from are 4.8.5 and 5.2.0, it will return 4.8.5, as binaries compiled with that version will run on this platform, whereas binaries compiled with 5.2.0 may not.\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{Base.BinaryPlatforms.AbstractPlatform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.generate_compiler_wrappers!","text":"generate_compiler_wrappers!(platform::AbstractPlatform; bin_path::AbstractString,\n                            host_platform::AbstractPlatform = Platform(\"x86_64\", \"linux\"; libc = \"musl\", cxxstring_abi = \"cxx11\"),\n                            compilers::Vector{Symbol} = [:c],\n                            allow_unsafe_flags::Bool = false,\n                            lock_microarchitecture::Bool = true,\n                            gcc_version::Union{Nothing,VersionNumber}=nothing,\n                            clang_version::Union{Nothing,VersionNumber}=nothing,\n                            clang_use_lld::Bool = false,\n                            )\n\nWe generate a set of compiler wrapper scripts within our build environment to force all build systems to honor the necessary sets of compiler flags to build for our systems. Note that while platform_envs() sets many environment variables, those values are intended to be optional/overridable.  These values, while still overridable by directly invoking a compiler binary directly (e.g. /opt/{target}/bin/{target}-gcc), are much more difficult to override, as the flags embedded in these wrappers are absolutely necessary, and even simple programs will not compile without them.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.generate_per_uid_squashfs","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.generate_per_uid_squashfs","text":"generate_per_uid_squashfs(cs, new_uid = getuid())\n\nIn order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unprivileged user.  Unfortunately there is no mount-time option to do this for us.  Fortunately, squashfs is simple enough that if the ID table is uncompressed, we can just manually patch the uids to be what we need.  This function performs this operation, by rewriting all UIDs and GIDs to the given new_uid (which defaults to the current user's UID).\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.get_addable_spec-Tuple{AbstractString, VersionNumber}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.get_addable_spec","text":"get_addable_spec(name::AbstractString, version::VersionNumber)\n\nGiven a JLL name and registered version, return a PackageSpec that, when passed as a Dependency, ensures that exactly that version will be installed.  Example usage:\n\ndependencies = [\n    BuildDependency(get_addable_spec(\"LLVM_jll\", v\"9.0.1+0\")),\n]\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.get_commit_sha-Tuple{String, Base.SHA1}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.get_commit_sha","text":"get_commit_sha(url::String, tree_hash::Base.SHA1; verbose::Bool=false)\n\nFind the latest git commit corresponding to the given git tree SHA1 for the remote repository with the given url.  The repository is cached locally for quicker future access.  If verbose is true, print to screen some debugging information.\n\nThe return value is the commit SHA as a String, if the corresponding revision is found, nothing otherwise.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.get_concrete_platform-Tuple{Base.BinaryPlatforms.AbstractPlatform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.get_concrete_platform","text":"get_concrete_platform(platform::AbstractPlatform;\n                      preferred_gcc_version = nothing,\n                      preferred_llvm_version = nothing,\n                      compilers = nothing)\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI.  The set of shards is chosen by the keyword arguments (see choose_shards).\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.get_concrete_platform","text":"get_concrete_platform(platform::Platform, shards::Vector{CompilerShard})\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI in the shards.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.get_tree_hash-Tuple{LibGit2.GitTree}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.get_tree_hash","text":"get_tree_hash(tree::LibGit2.GitTree)\n\nGiven a GitTree, get the GitHash that identifies it.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.getgid-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.getgid","text":"getgid()\n\nWrapper around libc's getgid() function\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.getuid-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.getuid","text":"getuid()\n\nWrapper around libc's getuid() function\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.import_docker_image","text":"import_docker_image(rootfs::CompilerShard; verbose::Bool = false)\n\nChecks to see if the given rootfs has been imported into docker yet; if it hasn't, then do so so that we can run things like:\n\ndocker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash\n\nWhich, after all, is the foundation upon which this whole doodad is built.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.includedir-Tuple{Prefix}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.includedir","text":"includedir(prefix::Prefix)\n\nReturns the include directory for the given prefix\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.installed_shards-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.installed_shards","text":"installed_shards()\n\nReturn a vector of compiler shards currently downloaded on the local system\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.is_build_dependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.is_build_dependency","text":"is_build_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a build-time dependency or not.\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.is_ecryptfs","text":"is_ecryptfs(path::AbstractString; verbose::Bool=false)\n\nChecks to see if the given path (or any parent directory) is placed upon an ecryptfs mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603\n\nThis method returns whether it is encrypted or not, and what mountpoint it used to make that decision.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.is_host_dependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.is_host_dependency","text":"is_host_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a dependency of the host platform or not.\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.is_mounted","text":"is_mounted(cs::CompilerShard, build_prefix::String)\n\nReturn true if the given shard is mounted.  Uses run() so will error out if something goes awry.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.is_runtime_dependency","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.is_runtime_dependency","text":"is_runtime_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a runtime dependency or not.\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.is_target_dependency","text":"is_target_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a dependency of the target platform or not.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.is_top_level_dependency-Tuple{AbstractDependency}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.is_top_level_dependency","text":"is_top_level_dependency(dep::AbstractDependency) -> Bool\n\nReturn wheter dep is a top-level dependency or not.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.libabi_agnostic-Tuple{Platform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.libabi_agnostic","text":"abi_agnostic(p::AbstractPlatform)\n\nLike abi_agnostic, but keep the sanitizer ABI tags.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.libdirs","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.libdirs","text":"libdirs(prefix::Prefix, platform = HostPlatform())\n\nReturns the library directories for the given prefix (note that this differs between unix systems and windows systems, and between 32- and 64-bit systems).\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.locate","text":"locate(ep::ExecutableProduct, prefix::Prefix;\n       platform::AbstractPlatform = HostPlatform(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given executable file exists and is executable, return its path.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set. On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.locate","text":"locate(fp::FileProduct, prefix::Prefix;\n       platform::AbstractPlatform = HostPlatform(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given file exists, return its path.  The platform and isolate arguments are is ignored here, but included for uniformity.  For ease of use, we support a limited number of custom variable expansions such as ${target}, and ${nbits}, so that the detection of files within target-specific folders named things like /lib32/i686-linux-musl is simpler.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.locate","text":"locate(lp::LibraryProduct, prefix::Prefix;\n       verbose::Bool = false,\n       platform::AbstractPlatform = HostPlatform())\n\nIf the given library exists (under any reasonable name) and is dlopen()able, (assuming it was built for the current platform) return its location.  Note that the dlopen() test is only run if the current platform matches the given platform keyword argument, as cross-compiled libraries cannot be dlopen()ed on foreign platforms.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.logdir-Tuple{Prefix}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.logdir","text":"logdir(prefix::Prefix; subdir::AbstractString=\"\")\n\nReturns the logs directory for the given prefix.  If subdir is a non-empty string, that directory it is appended to the logdir of the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.macos_sdk_already_installed","text":"macos_sdk_already_installed()\n\nReturns true if any piece of the MacOS SDK is already installed.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.manage_shards-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.manage_shards","text":"manage_shards(; sort_by=:name, rev=false)\n\nOpen a prompt allowing a user to selectively remove downloaded compiler shards. By default, the shards are sorted by name, alternatively you can sort them by file size on disk by specifying sort_by=:size. With rev=true you can reverse the sort order.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.map_target-Tuple{CompilerShard}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.map_target","text":"map_target(cs::CompilerShard)\n\nReturn the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.mount","text":"mount(cs::CompilerShard, build_prefix::String)\n\nMount a compiler shard, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a .squashfs shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.package","text":"package(prefix::Prefix, output_base::AbstractString,\n        version::VersionNumber;\n        platform::AbstractPlatform = HostPlatform(),\n        verbose::Bool = false, force::Bool = false,\n        filter = Returns(true))\n\nBuild a tarball of the prefix, storing the tarball at output_base, appending the version number version, a platform-dependent suffix and a file extension.  If platform is not given, defaults to current platform. Returns the full path to, the SHA256 hash and the git tree SHA1 of the generated tarball.\n\nThe are additional keyword arguments:\n\nverbose controls whether to print information to screen,\nforce makes the function overwrite an existing tarball with the same name\nfilter is a 2-argument function which returns true if the given file or directory should be packaged, and false otherwise.  The arguments are (prefix, path), where prefix is the directory where the prefix is stored, and path is the path, within the prefix, of the file or directory.  This keyword allows you to filter out from the tarball certain files or directories.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.platform_envs-Tuple{Base.BinaryPlatforms.AbstractPlatform, AbstractString}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.platform_envs","text":"platform_envs(platform::AbstractPlatform, src_name::AbstractString;\n              host_platform = default_host_platform,\n              bootstrap::Bool=!isempty(bootstrap_list),\n              compilers::Vector{Symbol}=[:c],\n              rust_version::Union{Nothing,VersionNumber}=nothing,\n              verbose::Bool = false,\n              )\n\nGiven a platform and a src_name, generate a Dict mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are PATH, CC, RANLIB, as well as nonstandard things like target.\n\nAccepted keyword arguments are:\n\nhost_platform: the platform of the host system,\nbootstraop: if true, only basic environment variables will be generated,\ncompilers: list of compilers, some environment variables will be generated only if the relevant compilers are used (e.g., for Go and Rust),\nrust_version: version of the Rust toolchain, needed to set the environment variable RUSTUP_TOOLCHAIN,\nverbose: holds the value of the V and VERBOSE environment variables.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.platform_exeext-Tuple{Base.BinaryPlatforms.AbstractPlatform}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.platform_exeext","text":"platform_exeext(p::AbstractPlatform)\n\nGet the executable extension for the given Platform.  Includes the leading ..\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.preferred_cxxstring_abi","text":"preferred_cxxstring_abi(platform::AbstractPlatform, shard::CompilerShard;\n                        gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the C++ string ABI preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.preferred_libgfortran_version-Tuple{Base.BinaryPlatforms.AbstractPlatform, CompilerShard}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.preferred_libgfortran_version","text":"preferred_libgfortran_version(platform::AbstractPlatform, shard::CompilerShard;\n                              gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the libgfortran version preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.runshell","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.runshell","text":"runshell(platform::AbstractPlatform = HostPlatform())\n\nLaunch an interactive shell session within the user namespace, with environment setup to target the given platform.\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.satisfied","text":"satisfied(p::Product;\n          platform::AbstractPlatform = HostPlatform(),\n          verbose::Bool = false,\n          isolate::Bool = false)\n\nGiven a Product, return true if that Product is satisfied, e.g. whether a file exists that matches all criteria setup for that Product. If isolate is set to true, will isolate all checks from the main Julia process in the event that dlopen()'ing a library might cause issues.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.setup_workspace","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.setup_workspace","text":"setup_workspace(build_path::String, sources::Vector{SetupSource};\n                verbose::Bool = false)\n\nSets up a workspace within build_path, creating the directory structure needed by further steps, unpacking the source within build_path, and defining the environment variables that will be defined within the sandbox environment.\n\nThis method returns the Prefix to install things into, and the runner that can be used to launch commands within this workspace.\n\n\n\n\n\n","category":"function"},{"location":"#BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.shard_mappings","text":"shard_mappings(shards::Vector{CompilerShard})\n\nReturn the default mappings for a set of compiler shards\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.shard_path-Tuple{CompilerShard}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.shard_path","text":"shard_path(cs::CompilerShard)\n\nReturn the path to this shard on-disk; for unpacked shards, this is a directory. For squashfs shards, this is a file.  This will not cause a shard to be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.supported_platforms-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.supported_platforms","text":"supported_platforms(;exclude::Union{Vector{<:Platform},Function}=Returns(false),\n                    experimental::Bool=false)\n\nReturn the list of supported platforms as an array of Platforms.  These are the platforms we officially support building for, if you see a mapping in get_shard_hash() that isn't represented here, it's probably because that platform is still considered \"in beta\".  If experimental=true, include platforms considered experimental.\n\nPlatforms can be excluded from the list by specifying an array of platforms to exclude i.e. supported_platforms(exclude=[Platform(\"i686\", \"windows\"), Platform(\"x86_64\", \"windows\")]) or a function that returns true for exclusions i.e.\n\nsupported_platforms(exclude=Sys.islinux)\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.temp_prefix-Tuple{Function}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.temp_prefix","text":"temp_prefix(func::Function)\n\nCreate a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.\n\nUsage example:\n\nout_path = abspath(\"./libfoo\")\ntemp_prefix() do p\n    # <insert build steps here>\n\n    # tarball up the built package\n    tarball_path, tarball_hash = package(p, out_path)\nend\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.uname-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.uname","text":"uname()\n\nOn Linux systems, return the strings returned by the uname() function in libc\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.unmount-Tuple{CompilerShard, String}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.unmount","text":"unmount(cs::CompilerShard, build_prefix::String)\n\nUnmount a compiler shard from a given build prefix, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a squashfs shard on Linux.  All other combinations of shard archive type and platform result in a no-op.\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.variable_name-Tuple{Product}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.variable_name","text":"variable_name(p::Product)\n\nReturn the variable name associated with this Product as a string\n\n\n\n\n\n","category":"method"},{"location":"#BinaryBuilderBase.versioninfo-Tuple{}","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.versioninfo","text":"versioninfo()\n\nHelper function to print out some debugging information\n\n\n\n\n\n","category":"method"},{"location":"#Constants","page":"BinaryBuilderBase.jl Documentation","title":"Constants","text":"","category":"section"},{"location":"#BinaryBuilderBase.default_host_platform","page":"BinaryBuilderBase.jl Documentation","title":"BinaryBuilderBase.default_host_platform","text":"default_host_platform\n\nThe default host platform in the build environment.\n\n\n\n\n\n","category":"constant"}]
}
